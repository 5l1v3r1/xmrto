#!/usr/bin/env python3
# TODO remote node support
# TODO verify transaction amounts with conversion API
# TODO figure out ring_size
# TODO generate rpc creds
# TODO support generating deposit address

import urllib.parse
import subprocess
import traceback
import requests
import argparse
import decimal
import random
import signal
import socket
import atexit
import pprint
import json
import time
import math
import sys
import os
import re

import utils

#
# Monero Wallet config file compatibility defaults:
#

# Location of Monero config file
# Override with -c/--monero-config
default_monero_config = '{}/.config/monero-project/monero-core.conf'.format(os.environ['HOME'])

#
# Wallet RPC connection defaults:
#

# Wallet RPC port (both for connection and optional autostart)
# Override with --rpc-port
default_rpc_port = 18083

# Wallet RPC host (for connection)
# Override with --rpc-host
default_rpc_host = '127.0.0.1'

# RPC credentials ('user:pass') (both for connection and optional autostart).
# Override with --rpc-creds
default_rpc_creds = None

# Get RPC credentials from a .login file generated by monero-wallet-rpc (both
# for connection and optional autostart). File format is 'user:pass'.
# Override with --rpc-login
default_rpc_login_file = None

#
# Churn defaults:
#

#default_churn_transactions = 1

#
# Autopay defaults:
#

# Maximum autopay amount XMR. This is a safety mechanism.
# Override with -m/--max-autopay
default_autopay_max = decimal.Decimal(4.0)

# Account index integer. None is automatic.
# Override with -A/--account
#default_autopay_account = None
default_autopay_account = '0'

# Payment priority. See `payment_priorities` below.
# Override with --priority
default_autopay_priority = 'auto'

# Number of mixins. None uses the maximum of xmr.to recommended number of
# mixins and default_autopay_mixins_minimum. 4 mixins is the GUI wallet
# default. Higher is better for privacy but slower.
# Override with --mixins
default_autopay_mixins = None
default_autopay_mixins_minimum = 10

# The default ring_size is 7. See discussion here: https://github.com/monero-project/monero/issues/4229
# Probably best not to change this
default_autopay_ring_size = None

# Actual lock time is 10 + unlock_time blocks.
# Override with --unlock-time
default_autopay_unlock_time = None

#
# Autostart daemon defaults:
#

# Try to start Monero daemon?
# Override with --autostart-daemon or --no-autostart-daemon
default_autostart_daemon = True

# Program to run
default_monero_daemon = 'monerod'

# Daemon config file
# Override with --daemon-config
default_daemon_config = None

# Daemon blockchain data directory
# Override with --daemon-data-dir
default_daemon_data_dir = None

# Port to bind monerod to
default_daemon_port = 18081

# Additional monerod arguments
# Override with --daemon-arg
default_daemon_args = []

# Log files
default_daemon_log = '/tmp/xmrto.daemon.log'
default_daemon_log_level = 0
default_daemon_pid = '/tmp/xmrto.daemon.pid'

#
# Autostart wallet RPC defaults:
#

# Try to start Monero wallet RPC?
# Override with --autostart-wallet-rpc or --no-autostart-wallet-rpc
default_autostart_wallet_rpc = True

# Program to run
default_monero_wallet_rpc = 'monero-wallet-rpc'

# Monero wallet .keys file. None tries to use the value from
# ~/.config/monero-project/monero-core.conf
# Override with --wallet
default_wallet_file = None

# Wallet password
# Override with --wallet-password
default_wallet_password = ''

# These arguments are appended to the following arguments:
#  > --rpc-bind-port: Value from default_rpc_port or --rpc-port
#  > --rpc-login: Value from default_rpc_creds, default_rpc_login_file,
#    --rpc-creds, or --rpc-login-file
#  > --wallet-file: Value from ~/.config/monero-project/monero-core.conf,
#    default_wallet_file, --wallet
#  > --password: Value from default_wallet_password or --wallet-password
# Override with --rpc-arg
default_wallet_rpc_args = []

# Monero daemon host:port to connect to
# Override with --daemon-address
default_daemon_address = '127.0.0.1:{}'.format(default_daemon_port)

# Log files
default_wallet_rpc_log = '/tmp/xmrto.wallet-rpc.log'
default_wallet_rpc_log_level = 0
default_wallet_rpc_pid = '/tmp/xmrto.wallet-rpc.pid'

#
# General defaults:
#

# User-agent for all API requests
default_user_agent = ''

# Sleep time when retrying after certain errors
default_error_sleep = 5

# Sleep time for the status poll stage (see -n/--no-status)
default_status_sleep = 10

# Autostart poll times
default_autostart_poll_sleep = 0.5
default_autostart_poll_max = 15
default_autostart_poll_tries = default_autostart_poll_max / default_autostart_poll_sleep

# Default fiat coin (USD, EUR, or None)
default_fiat = 'USD'

#
# API base URLs:
#

# API base address for xmr.to
xmrto_api_base = 'https://xmr.to/api/v3/xmr2btc'

# API base address for fiat conversions
btcven_api_base = 'https://api.bitcoinvenezuela.com/'

# Payment priority name -> number translations
payment_priorities = {
     'auto':        0,
     'default':     0,
     'unimportant': 1,
     'normal':      2,
     'elevated':    3,
     'priority':    4,
}

# Order state identifiers -> description translations
states = {
    'TO_BE_CREATED': 'Order creation pending',
    'UNPAID': 'Waiting for Monero payment',
    'UNDERPAID': 'Order partially paid',
    'PAID_UNCONFIRMED': 'Order paid, waiting for confirmations',
    'PAID': 'Order paid and confirmed',
    'BTC_SENT': 'Bitcoin payment sent',
    'TIMED_OUT': 'Order timed out before payment was complete',
    'NOT_FOUND': "Order wasn't found in system (never existed or was purged)",
}

kill_on_exit = False
daemon_pid = None
wallet_rpc_pid = None

def cleanup():
    if daemon_pid or wallet_rpc_pid:
        print()

        if daemon_pid:
            utils.info('Monero daemon will continue running in the background. PID: {}'.format(daemon_pid))

        if wallet_rpc_pid:
            utils.info('Monero wallet RPC daemon will continue running in the background. PID: {}'.format(wallet_rpc_pid))

def is_running(pid):
    """
    Check if a process is running, by PID

    :param pid: PID to check
    :return: True of the process is running
    """

    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False

def read_pidfile(fname):
    """
    Read a file containing a PID

    :param fname: PID file
    :return: PID if file was readable and PID is running, else None
    """

    try:
        with open(fname, 'r') as fp:
            pid = int(fp.read())

        return pid
    except:
        return None

def is_int(value):
    """
    Is this string an integer?

    :param value: String to check
    :return: True if it is
    """

    try:
        int(value)
        return True
    except ValueError:
        return False

# XMR atomic unit conversion constant
# See https://www.getmonero.org/resources/moneropedia/atomic-units.html
# 1/10**12
piconero = decimal.Decimal('0.000000000001')

def to_atomic(amount):
    """
    Convert to atomic value
    
    :param amount: String decimal XMR amount
    :return: Integer XMR atomic amount
    """

    decimal_amount = decimal.Decimal(amount) / piconero
    decimal_amount = decimal_amount.quantize(decimal.Decimal('1'))
    return int(decimal_amount)

def from_atomic(amount):
    """
    Convert from atomic value
    
    :param amount: Integer XMR atomic amount
    :return: String decimal XMR amount
    """

    decimal_amount = decimal.Decimal(amount) * piconero
    decimal_amount = decimal_amount.quantize(piconero)
    return decimal_amount.normalize()

def test_atomic_conversions():
    """
    Test atomic unit conversion functions
    """

    values = ('0.13452345324',
              '0.13999999949',
              '0.99999999999',
              '0.11111111111',
              '0.00000000001',
              '0.99999000001',
              '241340123412.999999999999',
              '0.00000099999')

    for value in values:
        value = decimal.Decimal(value)
        atomic = to_atomic(value)
        reconv = from_atomic(atomic)
        utils.info('{} -> {} -> {}'.format(value, atomic, reconv))
        assert(reconv == value)

def display_order_status(uuid):
    """
    Display order status

    :param uuid: Order UUID
    """

    status = xmrto_api_order_status(uuid)
    state = status['state']

    # Base information
    utils.subline('- Order ID: {}'.format(uuid))
    utils.subline('- State: {}'.format(states[state]))

    if state in ('UNPAID', 'UNDERPAID'):
        # Unpaid
        utils.subline('- Address (XMR): {}'.format(status['receiving_subaddress']))
        utils.subline('- Requested (XMR): {}'.format(status['incoming_amount_total']))
        if state == 'UNDERPAID':
            utils.subline('- Remaining (XMR): {}'.format(status['remaining_amount_incoming']))
        utils.subline('- Expiration: {} seconds'.format(status['seconds_till_timeout']))

    elif state in ('PAID', 'PAID_UNCONFIRMED'):
        # Paid
        utils.subline('- Paid (XMR): {}'.format(status['incoming_amount_total']))
        if state == 'PAID_UNCONFIRMED':
            utils.subline('- Confirmations left: {}'.format(status['incoming_num_confirmations_remaining']))

    elif state == 'BTC_SENT':
        # BTC sent
        utils.subline('- Address (BTC): {}'.format(status['btc_dest_address']))
        utils.subline('- Sent (BTC): {}'.format(status['btc_amount']))
        utils.subline('- Transaction: {}'.format(status['btc_transaction_id']))
        utils.subline('- Confirmations: {}'.format(status['btc_num_confirmations']))

def find_account(account=None, minimum_unlocked=None, **rpc_config):
    """
    Find an account matching an index, tag, or label or minimum balance

    :param account: Account index, tag, or label (string)
    :param minimum_unlocked: Minimum unlocked balance (alternative to `account`)
    :param **rpc_config: RPC config
    :return: (account_index, display_label)
    """

    try:
        result = wallet_get_accounts(**rpc_config)
    except Exception as e:
        # RPC 'get_accounts' request failed
        utils.die(str(e))

    accounts = result['subaddress_accounts']
    found_accounts = {}

    for account_info in accounts:
        if account:
            if (is_int(account) and account_info['account_index'] == int(account)) or \
               (account.lower() == account_info['tag'].lower()) or \
               (account.lower() == account_info['label'].lower()):
                found_accounts[account_info['account_index']] = account_info
        elif minimum_unlocked:
            if account_info['unlocked_balance'] >= minimum_unlocked:
                found_accounts[account['account_index']] = account_info
        else:
            raise RuntimeError('Account descriptor or minimum unlocked balance not specified')

    display_labels = ', '.join(['{} ({})'.format(index, account['label']) for index, account in found_accounts.items()])

    if not found_accounts:
        # No accounts found
        if account:
            utils.die('No accounts found matching {}'.format(account))
        else:
            utils.die('No accounts found with an unlocked balance above {}. Let the Monero daemon sync. If you recently made a transaction wait for the change funds to unlock.'.format(xmr_amount))
    elif len(found_accounts) > 1:
        # Multiple accounts found
        if account:
            utils.die('Multiple accounts found matching {}: {}'.format(account, display_labels))
        else:
            utils.die('Multiple accounts found with an unlocked balance above {}. Use -A/--account to select one: {}'.format(xmr_amount, display_labels))
    else:
        # Found one account
        from_account_index = list(found_accounts.keys())[0]
        return from_account_index, display_labels

def wallet_get_balance(account=None, unlocked=False, **rpc_config):
    """
    Get balance of wallet or entire account

    :param account: Get balance for this account
    :param unlocked: Get unlocked balance
    :param **rpc_config: RPC config
    :return: Balance in atomic units
    """

    try:
        result = wallet_get_accounts(**rpc_config)
    except Exception as e:
        # RPC request failed
        utils.die(str(e))

    if account is None:
        if unlocked:
            return result['total_unlocked_balance']
        else:
            return result['total_balance']
    else:
        accounts = result['subaddress_accounts']

        for account_info in accounts:
            if account_info['account_index'] == account:
                if unlocked:
                    return account_info['unlocked_balance']
                else:
                    return account_info['balance']

        raise RuntimeError('Account {} not found'.format(account))

def display_wallet_balances(**rpc_config):
    """
    Display wallet balances

    :param **rpc_config: RPC config
    """

    try:
        result = wallet_get_accounts(**rpc_config)
    except Exception as e:
        # RPC request failed
        utils.die(str(e))

    accounts = result['subaddress_accounts']
    total_balance = from_atomic(result['total_balance'])
    total_unlocked_balance = from_atomic(result['total_unlocked_balance'])

    utils.info('Wallet balances:')

    utils.subline('Total balance: {} XMR'.format(total_balance.normalize()))
    utils.subline('Unlocked balance: {} XMR'.format(total_unlocked_balance.normalize()))

    for account in accounts:
        locked_note = ''
        unlocked_note = ''

        balance = account['balance']
        locked_balance = balance - account['unlocked_balance']
        unlocked_balance = account['unlocked_balance']

        if locked_balance > 0:
            if locked_balance == balance:
                locked_note = ' (locked)'.format(from_atomic(locked_balance).normalize())
            else:
                locked_note = ' (locked: {} XMR)'.format(from_atomic(locked_balance).normalize())

        utils.subline(' - {} ({}): {} XMR{}'.format(account['label'], account['account_index'], from_atomic(balance).normalize(), locked_note))

def display_wallet_addresses(unused_only=False, **rpc_config):
    """
    Display wallet addresses

    :param unused_only: Only show unused addresses
    :param **rpc_config: RPC config
    """

    try:
        result = wallet_get_accounts(**rpc_config)
    except Exception as e:
        # RPC request failed
        utils.die(str(e))

    accounts = result['subaddress_accounts']
    total_balance = from_atomic(result['total_balance'])
    total_unlocked_balance = from_atomic(result['total_unlocked_balance'])

    utils.info('Wallet addresses:')

    for account in accounts:
        locked_note = ''
        unlocked_note = ''

        balance = account['balance']
        locked_balance = balance - account['unlocked_balance']
        unlocked_balance = account['unlocked_balance']

        if locked_balance > 0:
            if locked_balance == balance:
                locked_note = ' (locked)'.format(from_atomic(locked_balance).normalize())
            else:
                locked_note = ' (locked: {} XMR)'.format(from_atomic(locked_balance).normalize())

        try:
            result = wallet_get_address(account['account_index'], **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        base_address = result['address']

        utils.subline(' - {}: {} ({} XMR{})'.format(account['account_index'],
            account['label'], from_atomic(balance).normalize(), locked_note))

        for address_info in result['addresses']:
            address = address_info['address']
            index = address_info['address_index']
            label = address_info['label']
            used = address_info['used']

            if not (unused_only and used):
                used_note = ' (used)' if used else ''
                utils.subline('     - {}: {} {}{}'.format(index, address, label, used_note))

def xmrto_api_order_parameters():
    """
    Query order parameters

    :return: {lower_limit, price, upper_limit, zero_conf_enabled, zero_conf_max_amount}
                           ^ 1 btc in xmr
    """

    result = xmrto_api('order_parameter_query')

    if 'lower_limit' not in result:
        raise RuntimeError('Failed to query order parameters: bad data: {}'.format(result))

    return result

def xmrto_api_order_create(address, amount=None):
    """
    Create a new order

    :param address: Bitcoin address or payment URL
    :param amount: Bitcoin amount (if not using payment URL)
    :return: {state, btc_amount, btc_dest_address, uuid, [pp_url]}
    """

    if amount is None:
        data = {
            "pp_url": address,
        }
        result = xmrto_api('order_create_pp', data)
    else:
        data = {
            "btc_dest_address": address,
            "amount_currency": 'BTC',
            "amount": str(amount),
        }
        result = xmrto_api('order_create', data)

    if 'state' not in result:
        raise RuntimeError('Failed to create order for {} {}: bad data: {}'.format(address, amount, result))

    if result['state'] not in ('TO_BE_CREATED', 'UNPAID'):
        raise RuntimeError('Failed to create order for {} {}: {}'.format(address, amount, result['state']))

    return result

def xmrto_api_order_status(uuid):
    """
    Check order status

    :param uuid: Order UUID
    :return: { state,
               btc_amount,
               btc_dest_address,
               uuid,
               btc_num_confirmations,
               btc_num_confirmations_before_purge,
               btc_transaction_id,
               created_at,
               expires_at,
               seconds_till_timeout,
               xmr_amount_total,
               xmr_amount_remaining,
               xmr_num_confirmations_remaining,
               xmr_price_btc,
               xmr_receiving_integrated_address,
               xmr_recommended_mixin,

               # old-style address/payment:
               xmr_receiving_address,
               xmr_required_amount,
               xmr_required_payment_id_long,
               xmr_required_payment_id_short }
    """

    result = xmrto_api('order_status_query', {'uuid': uuid})

    if 'state' not in result:
        raise RuntimeError('Failed to query status for order {}: bad data: {}'.format(uuid, result))

    return result

def xmrto_api_order_price(uuid):
    """
    Check order price

    :param uuid: Order UUID
    :return: { btc_amount, xmr_amount_total, xmr_num_confirmations_remaining, xmr_price_btc }
    """

    result = xmrto_api('order_check_price', {'uuid': uuid})

    if 'btc_amount' not in result:
        raise RuntimeError('Failed to query price for order {}: bad data: {}'.format(uuid, result))

    return result

def xmrto_api(endpoint, data=None):
    """
    Make an API request. Makes a GET request unless :data: is specified.

    :param endpoint: REST endpoint
    :param data: Send a POST request with this data
    :return: Decoded response
    """

    url = '{}/{}/'.format(xmrto_api_base, endpoint)

    headers = {
        'User-Agent': default_user_agent,
    }

    while True:
        if data is None:
            # GET request
            utils.debug('Making API GET request to {}...'.format(url))
            resp = requests.get(url, headers=headers)
        else:
            # POST request
            headers['Content-Type'] = 'application/json'
            payload = json.dumps(data)

            utils.debug('Making API POST request to {}...'.format(url))
            utils.debug('Payload: {}'.format(payload))
            resp = requests.post(url, payload, headers=headers)

        try:
            decoded = json.loads(resp.content, parse_float=decimal.Decimal)
        except json.decoder.JSONDecodeError:
            # Bad data
            raise RuntimeError('API request to {} returned non-json data: {}'.format(url, resp.content))

        # Request failed
        if not resp.ok:
            # Special case for 'service not available in your region': retry
            if 'error' in decoded:
                if decoded['error'] == 'XMRTO-ERROR-014':
                    utils.bad('Xmr.to is not available in the US. Switch Tor exits or start your VPN. Trying again in {} seconds...'.format(default_error_sleep))
                    time.sleep(default_error_sleep)
                    continue

            # All other errors: exit
            if 'error_msg' in decoded:
                error = decoded['error_msg']
            elif 'detail' in decoded:
                error = decoded['detail']
            else:
                error = 'no error message: {}'.format(decoded)

            raise RuntimeError('API request to {} failed with code {}: {}'.format(url, resp.status_code, error))

        return decoded

def btcven_convert(amount, coin='BTC', fiat=default_fiat):
    """
    Convert crypto amount to fiat using bitcoinvenezuala

    :param amount: Crypto amount
    :param coin: Crypto coin
    :param fiat: Fiat
    :return: Float fiat amount
    """

    headers = {
        'User-Agent': default_user_agent,
    }

    params = {
        'html': 'no',
        'currency': 'BTC',
        'amount': '1',
        'to': 'USD',
    }

    utils.debug('Making GET request to {}'.format(btcven_api_base))
    resp = requests.get(btcven_api_base, headers=headers, params=params)

    if resp.ok:
        return decimal.Decimal(resp.content) * amount
    else:
        raise RuntimeError('Btcven API request to {} failed with code {}'.format(url, resp.status_code))

def btcven_convert_note(amount, coin='BTC', fiat=default_fiat):
    """
    Convert crypto amount to fiat using bitcoinvenezuala and make a text note for it

    :param amount: Crypto amount
    :param coin: Crypto coin
    :param fiat: Fiat
    :return: Pretty string fiat amount
    """

    if fiat and fiat != 'off':
        try:
            fiat_estimate = btcven_convert(amount, fiat=fiat)
        except Exception as e:
            # Fail silently
            return ''
        if fiat_estimate:
            return ' (~{:.2f} {})'.format(fiat_estimate, fiat)

    return ''

def wallet_api(method, params=None, version='2.0', id='0',
        rpc_host=default_rpc_host, rpc_port=default_rpc_port,
        rpc_creds=default_rpc_creds):
    """
    Make a Monero wallet API request

    See https://www.getmonero.org/resources/developer-guides/wallet-rpc.html

    :param method: JSON RPC method
    :param params: Parameters
    :param version: JSON RPC version
    :param id: Not used?
    :param rpc_host: RPC host
    :param rpc_port: RPC port
    :param rpc_creds: RPC credentials, user:pass (monero-wallet-rpc --rpc-login)
    :return: Decoded response
    """

    # Auth
    if rpc_creds:
        rpc_user, rpc_password = rpc_creds.split(':')
        auth = requests.auth.HTTPDigestAuth(rpc_user, rpc_password)
    else:
        auth = None

    headers = {
        'User-Agent': default_user_agent,
        'Content-Type': 'application/json',
    }

    data = {
        'jsonrpc': version,
        'id': id,
        'method': method,
        'params': params
    }

    url = 'http://{}:{}/json_rpc'.format(rpc_host, rpc_port)
    payload = json.dumps(data)
    utils.debug('Making wallet RPC request: {} {}'.format(url, payload))
    try:
        resp = requests.post(url, headers=headers, auth=auth, data=payload)
    except Exception as e:
        raise RuntimeError('Wallet RPC connection to {} failed. Is monero-wallet-rpc running?'.format(url))

    if resp.ok:
        try:
            decoded = json.loads(resp.content, parse_float=decimal.Decimal)
        except json.decoder.JSONDecodeError:
            # Bad data
            raise RuntimeError('Wallet RPC request `{}` returned non-json data: {}'.format(method, resp.text))

        if 'error' in decoded:
            # Defined error
            error = decoded['error']['message']
            raise RuntimeError('Wallet API request `{}` failed: {}'.format(method, error))
        elif 'result' in decoded:
            return decoded['result']
        else:
            # Bad data
            raise RuntimeError('Wallet RPC request `{}` returned bad data: {}'.format(method, resp.text))
    else:
        raise RuntimeError('Wallet RPC request `{}` failed with code {}: {}'.format(method, resp.status_code, resp.text))

def wallet_transfer(address, amount, account=0, priority=default_autopay_priority,
        mixins=default_autopay_mixins, ring_size=default_autopay_ring_size,
        unlock_time=default_autopay_unlock_time,
        **kwargs):
    """
    Make a transfer from a Monero wallet.

    :param address: Address to send to
    :param amount: Amount to send (atomic units) ('all' to call sweep_all')
    :param account: Account to send from
    :param priority: Payment priority
    :param mixins: Number of mixins to use
    :param ring_size: Ring size
    :param unlock_time: Additional blocks before unlock (N + 10)
    :return: {amount, fee, multisig_txset, tx_hash}
    """

    priority_index = payment_priorities[priority]

    # Safety checks
    assert(mixins >= 4)

    params = {
        'account_index': account,
        'priority': priority_index,
        'mixin': mixins,
        'get_tx_key': True,
    }

    if ring_size:
        params['ring_size'] = ring_size

    if unlock_time:
        params['unlock_time'] = unlock_time

    if amount == 'all':
        # all monero (sweep_all)
        params['address'] = address
        return wallet_api('sweep_all', params, **kwargs)
    else:
        # partial transfer (transfer)
        params['destinations'] = [{'address': address, 'amount': amount}]
        return wallet_api('transfer', params, **kwargs)

def wallet_get_accounts(**kwargs):
    """
    Make get_accounts RPC request

    :return: {subaddress_accounts: [{account_index, balance, base_address, label, tag, unlocked_balance}...],
              total_balance,
              total_unlocked_balance}
    """

    return wallet_api('get_accounts', **kwargs)

def wallet_get_address(account=0, **kwargs):
    """
    Make get_address RPC request

    :param account: Account index
    :return: {address,
              addresses: {
               address,
               address_index,
               label,
               used
              }
             }
    """

    params = {
        'account_index': account,
    }

    return wallet_api('get_address', params, **kwargs)

def wallet_create_address(account=0, label=None, **kwargs):
    """
    Make create_address RPC request

    :param account: Account index
    :param label: Address label
    :return: {address,
              address_index}
    """

    params = {
        'account_index': account,
    }

    if label:
        params['label'] = label

    return wallet_api('create_address', params, **kwargs)

def check_tcp(host, port):
    """
    Check to see if TCP port is open

    :param host: Host
    :param port: Port
    """

    with socket.socket() as sock:
        sock.settimeout(0.5)
        return sock.connect_ex((host, port)) == 0

def is_daemon_synced(log_file):
    """
    Check if daemon is synced based on its logs

    :param log_file: Log file to check
    :return: True if the daemon is synced
    """

    daemon_synced = False
    with open(default_daemon_log, 'r') as fp:
        for line in fp:
            if 'You are now synchronized with the network' in line:
                daemon_synced = True
            elif 'The daemon will start synchronizing with the network' in line:
                daemon_synced = False

    return daemon_synced

def poll_daemon_sync(pid, log_file):
    """
    Poll the daemon sync status
    """

    daemon_synced = False
    last_current = 0
    last_top = 0
    last_lines = 0
    while is_running(pid) and not daemon_synced:
        with open(default_daemon_log, 'r') as fp:
            lines = fp.readlines()

            # Get new lines
            if len(lines) > last_lines:
                number_new = len(lines) - last_lines
                start_new = len(lines) - number_new
                new_lines = lines[start_new:]
                last_lines = len(lines)

                for line in new_lines:
                    if 'You are now synchronized with the network' in line:
                        yield last_top, last_top
                        daemon_synced = True
                        break

                    m = re.search('Sync data returned a new top block candidate: ([0-9]+) -> ([0-9]+)', line)
                    if not m:
                        m = re.search('Synced ([0-9]+)/([0-9]+)', line)
                    if m:
                        current = int(m.group(1))
                        top = int(m.group(2))
                        if current != last_current:
                            last_top = top
                            last_current = current
                            yield current, top

        time.sleep(default_autostart_poll_sleep)

def start_daemon(config=default_daemon_config, data_dir=None, additional_args=default_daemon_args):
    """
    Try to start the Monero daemon (monerod)

    :param config: Config file location
    :param additional_args: Additional monerod arguments
    :return: subprocess.Popen for process
    """

    args = [default_monero_daemon, '--rpc-bind-port', str(default_daemon_port),
            '--detach',
            '--log-file', default_daemon_log,
            '--max-log-file-size', '0',
            '--log-level', str(default_daemon_log_level),
            '--pidfile', default_daemon_pid]

    # Config
    if config:
        args += ['--config-file', config]

    if data_dir:
        args += ['--data-dir', data_dir]

    # Additional args
    if additional_args:
        args += additional_args

    # Check if daemon has already started
    if check_tcp('127.0.0.1', default_daemon_port):
        pid = None
        if os.path.isfile(default_daemon_pid):
            pid = read_pidfile(default_daemon_pid)

            if pid and is_running(pid):
                # It's one we started
                if is_daemon_synced(default_daemon_log):
                    utils.good('Monero daemon is already running and synced (PID {}).'.format(pid))
                    return pid
                else:
                    utils.info('Monero daemon is already running (PID {}). Waiting for daemon to sync...'.format(pid))
            else:
                # Not ours. Clear PID file.
                open(default_daemon_pid, 'w+').close()
                pid = None

        if not pid:
            # User must have started this daemon
            utils.good('Something is already listening on port {}. Assuming Monero daemon is already running and is not one we started.'.format(default_daemon_port))
            return None
    else:
        utils.info('Starting Monero daemon...')

        # Clear log and PID files
        open(default_daemon_log, 'w+').close()
        open(default_daemon_pid, 'w+').close()

        # Start process
        utils.debug('Starting daemon: {}'.format(' '.join(args)))
        proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE)

        # Wait for RPC port to open up
        tries = default_autostart_poll_tries
        while not check_tcp('127.0.0.1', default_daemon_port) and tries > 0:
            time.sleep(default_autostart_poll_sleep)
            tries -= 1

        if not check_tcp('127.0.0.1', default_daemon_port):
            # Daemon failed
            utils.bad('Failed to start Monero daemon. Error messages in {}:\n'.format(default_daemon_log))
            with open(default_daemon_log) as fp:
                for line in fp:
                    if '\tERROR' in line or '\tFATAL' in line or '\tWARN' in line:
                        utils.subline(line.strip())

            utils.die()
        else:
            # Daemon started
            # Read daemon PID
            pid = read_pidfile(default_daemon_pid)
            if not pid:
                utils.die('Failed to read Monero daemon PID file: {}'.format(default_daemon_pid))

            utils.info('Started Monero daemon (PID {}). Waiting for daemon to sync...'.format(pid))

    # Wait for daemon to sync
    daemon_synced = False
    for current, top in poll_daemon_sync(pid, default_daemon_log):
        if current == top:
            daemon_synced = True
            break
        utils.subline('blocks {} -> {}'.format(current, top))

    if not daemon_synced or not check_tcp('127.0.0.1', default_daemon_port):
        # Failed to sync
        utils.die('Monero daemon exited before sync was complete')
    else:
        # Sucessful sync
        utils.good('Monero daemon is synced')

    return pid

def start_wallet_rpc(creds=default_rpc_creds, port=default_rpc_port,
        wallet_file=default_wallet_file,
        wallet_password=default_wallet_password,
        daemon_address=default_daemon_address,
        additional_args=default_wallet_rpc_args):
    """
    Try to start the Monero wallet RPC daemon (monero-wallet-rpc)

    :param creds: RPC daemon credentials
    :param port: Port to listen on
    :param wallet_file: Wallet .keys file
    :param wallet_password: Wallet password
    :param daemon_address: Monero daemon address
    :param additional_args: Additional monero-wallet-rpc arguments
    :return: subprocess.Popen for process
    """

    args = [default_monero_wallet_rpc,
            '--detach',
            '--log-file', default_wallet_rpc_log,
            '--max-log-file-size', '0',
            '--log-level', str(default_wallet_rpc_log_level),
            '--pidfile', default_wallet_rpc_pid]

    # Alternative daemon address
    if daemon_address:
        args += ['--daemon-address', daemon_address]

    # Credentials
    if creds:
        args += ['--rpc-login', creds]
    else:
        args += ['--disable-rpc-login']

    # Port
    args += ['--rpc-bind-port', str(port)]

    # Wallet file
    if wallet_file:
        args += ['--wallet-file', wallet_file]

    # Wallet password
    args += ['--password', wallet_password]

    # Additional args
    if additional_args:
        args += additional_args

    # Check if wallet RPC has already started
    if check_tcp('127.0.0.1', port):
        pid = None
        if os.path.isfile(default_wallet_rpc_pid):
            pid = read_pidfile(default_wallet_rpc_pid)

            if pid and is_running(pid):
                # It's one we started
                utils.good('Wallet RPC is already running (PID {}).'.format(pid))
            else:
                # Not ours. Clear PID file.
                open(default_wallet_rpc_pid, 'w+').close()
                pid = None

        if not pid:
            utils.good('Something is already listening on port {}. Assuming wallet RPC is already running and is not one we started.'.format(port))
            return None
    else:
        utils.info('Starting Monero wallet RPC...')

        # Clear log and PID files
        open(default_wallet_rpc_log, 'w+').close()
        open(default_wallet_rpc_pid, 'w+').close()

        utils.debug('Starting wallet RPC: {}'.format(' '.join(args)))
        proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE)

        # Wait for RPC port to open up
        tries = default_autostart_poll_tries
        while not check_tcp('127.0.0.1', port) and tries > 0:
            time.sleep(default_autostart_poll_sleep)
            tries -= 1

        if not check_tcp('127.0.0.1', port):
            # Daemon failed to start
            utils.bad('Failed to start wallet RPC')
            with open(default_wallet_rpc_log) as fp:
                log_data = fp.read()
                utils.subline('Output from {}:\n\n{}'.format(default_monero_wallet_rpc, log_data))
            utils.die()
        else:
            # Daemon started
            # Read daemon PID
            pid = read_pidfile(default_wallet_rpc_pid)
            if not pid:
                utils.die('Failed to read wallet RPC PID file: {}'.format(default_daemon_pid))

            utils.good('Started Monero wallet RPC (PID {}).'.format(pid))

    return pid

def main():
    global daemon_pid
    global wallet_rpc_pid

    parser = argparse.ArgumentParser()
    group = parser.add_argument_group('alternative actions')
    group.add_argument('-P', '--show-parameters', action='store_true',
            help='Show xmr.to parameters and exit')
    group.add_argument('-S', '--status',
            help='Show status for a transaction (by UUID) and exit')
    group.add_argument('-E', '--estimate', action='store_true',
            help='Show XMR estimate and exit (does not send the order amount to xmr.to)')
    group.add_argument('--addresses', action='store_true',
            help='Get Monero wallet addresses and exit')
    group.add_argument('--unused', action='store_true',
            help='Get unused Monero wallet addresses and exit')
    group.add_argument('-C', '--create-address', metavar='LABEL',
            help='Make a new Monero wallet address for an account')
    group.add_argument('-B', '--balances', action='store_true',
            help='Get Monero wallet balances and exit')
    group.add_argument('-R', '--wallet-request',
            help='Run a Monero wallet RPC request and exit. Syntax: --wallet-request "method?param1=value&param2=value"')
    group.add_argument('-K', '--kill-daemons', action='store_true',
            help='Kill Monero daemons and exit')

    group = parser.add_argument_group('churn options')
    group.add_argument('--churn', action='store_true',
            help='Create a new address, send all funds to it')
    #group.add_argument('--churn-transactions', type=int, default=default_churn_transactions,
    #        help='Number of transactions to make (default: random between 3 and 6)')
    #group.add_argument('--test-conversions',
    #        help='Test conversion functions')

    group = parser.add_argument_group('autopay options')
    group.add_argument('-a', '--autopay', action='store_true',
            help='Try to automatically pay from a Monero wallet')
    group.add_argument('--rpc-host', default=default_rpc_host,
            help='Monero wallet RPC host (default: {})'.format(default_rpc_host))
    group.add_argument('--rpc-port', type=int, default=default_rpc_port,
            help='Monero wallet RPC port (default: {})'.format(default_rpc_port))
    group.add_argument('--rpc-creds', default=default_rpc_creds,
            help='Monero wallet RPC user:password (see monero-wallet-rpc --rpc-login) (default: {})'.format(default_rpc_creds))
    group.add_argument('--rpc-login-file', default=default_rpc_login_file,
            help='Monero wallet RPC .login file (default: {})'.format(default_rpc_login_file))
    group.add_argument('-m', '--max-autopay', default=default_autopay_max, type=decimal.Decimal,
            help='Maximum BTC amount to autopay (use with monero-wallet-rpc --rpc-login) (default: {})'.format(default_autopay_max))
    group.add_argument('-A', '--account', default=default_autopay_account,
            help='Wallet account to pay from (index, tag, or label) (default: auto)')
    group.add_argument('--priority', choices=payment_priorities.keys(), default=default_autopay_priority,
            help='Priority to send funds with (default: {})'.format(default_autopay_priority))
    group.add_argument('--mixins', default=default_autopay_mixins,
            help='Mixins to use with autopay (default: minimum of {} and the number xmr.to recommends)'.format(default_autopay_mixins_minimum))
    group.add_argument('--unlock-time', default=default_autopay_unlock_time,
            help='Additional unlock time in blocks (actual time will be N+10 blocks) (default: {})'.format(default_autopay_unlock_time))

    group = parser.add_argument_group('monero wallet config options')
    group.add_argument('-c', '--monero-config', default=default_monero_config,
            help='Monero Wallet config file (default: {})'.format(default_monero_config))
    group.add_argument('--no-monero-config', action='store_true',
            help='Do not use Monero config file')

    group = parser.add_argument_group('autostart daemon options')
    if default_autostart_daemon:
        group.add_argument('--no-autostart-daemon', action='store_false', dest='autostart_daemon',
                help='Do not try to start the monerod daemon')
    else:
        group.add_argument('--autostart-daemon', action='store_true',
                help="Try to start the monerod daemon if it's not already running")
    group.add_argument('--daemon-config', default=default_daemon_config,
            help='Daemon config file')
    group.add_argument('--daemon-data-dir', default=default_daemon_data_dir,
            help='Daemon blockchain data directory (default: {})'.format(default_daemon_data_dir))
    group.add_argument('--daemon-arg', action='append',
            help='Additional monerod daemon arguments')

    group = parser.add_argument_group('autostart wallet RPC options')
    if default_autostart_wallet_rpc:
        group.add_argument('--no-autostart-wallet-rpc', action='store_false', dest='autostart_wallet_rpc',
                help='Do not try to start monero-wallet-rpc')
    else:
        group.add_argument('--autostart-wallet-rpc', action='store_true',
                help="Try to start monero-wallet-rpc if it's not already running")
    group.add_argument('-W', '--wallet', default=default_wallet_file,
            help='Wallet .keys file (default: {})'.format(default_wallet_file))
    group.add_argument('-p', '--wallet-password', default=default_wallet_password,
            help='Wallet password (default: "{}")'.format(default_wallet_password))
    group.add_argument('--daemon-address', default=default_daemon_address,
            help='Monero daemon to connect to (default: {})'.format(default_daemon_address))
    group.add_argument('--rpc-arg', action='append',
            help='Additional monero-wallet-rpc arguments. --rpc-bind-port, --rpc-login, --wallet-file, and --password are set for you.')

    group = parser.add_argument_group('output options')
    group.add_argument('-f', '--fiat', default=default_fiat, choices=('USD', 'EUR', 'off'),
            help='Show fiat estimate during transaction with btcven (does not send amount to the server) (default: {})'.format(default_fiat))
    group.add_argument('-n', '--no-status', action='store_true',
            help='Do not wait for order to finish while showing status info')

    group = parser.add_argument_group('other options')
    group.add_argument('-D', '--debug', action='store_true',
            help='Show debug messages')

    group = parser.add_argument_group('bitcoin options')
    parser.add_argument('address', nargs='?',
            help='Bitcoin address, Monero address, or Bitcoin payment URL')
    parser.add_argument('amount', nargs='?',
            help='Bitcoin or Monero amount as a decimal amount. Specify min, max, or zeroconf to base the transaction amount on the xmr.to min, max, and zero-conf maximums respectively.')
    args = parser.parse_args()

    # -D/--debug
    utils.enable_debug = args.debug

    # Kill daemons?
    # -K/--kill-daemons
    if args.kill_daemons:
        daemon_pid = read_pidfile(default_daemon_pid)
        wallet_rpc_pid = read_pidfile(default_wallet_rpc_pid)

        if daemon_pid and is_running(daemon_pid):
            utils.info('Killing Monero daemon (PID {})'.format(daemon_pid))
            os.kill(daemon_pid, signal.SIGTERM)
        else:
            utils.info('Monero daemon is not running')

        if wallet_rpc_pid and is_running(wallet_rpc_pid):
            utils.info('Killing Monero wallet RPC (PID {})'.format(wallet_rpc_pid))
            os.kill(wallet_rpc_pid, signal.SIGTERM)
        else:
            utils.info('Monero wallet RPC is not running')

        return

    # Try to read Monero Wallet config
    wallet_file = args.wallet
    daemon_address = args.daemon_address
    daemon_data_dir = args.daemon_data_dir
    daemon_args = args.daemon_arg
    # -c/--monero-config, --no-monero-config
    if args.monero_config and not args.no_monero_config:
        utils.info('Reading Monero config from: {}'.format(args.monero_config))
        if os.path.exists(args.monero_config):
            with open(args.monero_config, 'r') as fp:
                for line in fp:
                    if line.startswith('#'):
                        # Comment
                        continue

                    key, *value_parts = line.split('=')
                    if not value_parts:
                        continue

                    key = key.strip()
                    value = '='.join(value_parts).strip()
                    if not value:
                        continue

                    if key == 'wallet_path' and not wallet_file:
                        utils.subline(' - Wallet path: {}'.format(value))
                        wallet_file = value
                    elif key == 'daemon_address' and not (args.autostart_daemon or args.daemon_address != default_daemon_address):
                        utils.subline(' - Daemon address: {}'.format(value))
                        daemon_address = value
                    elif key == 'blockchainDataDir' and not daemon_data_dir:
                        utils.subline(' - Blockchain data dir: {}'.format(value))
                        daemon_data_dir = value
                    elif key == 'daemonFlags' and not daemon_args:
                        daemon_args = value.split(' ')

        elif args.monero_config != default_monero_config:
            utils.die('Monero config file {} does not exist'.format(args.monero_config))

    # RPC config
    rpc_config = {
        'version': '2.0',
        'id': '0',
        'rpc_host': args.rpc_host,
        'rpc_port': args.rpc_port,
        'rpc_creds': None
    }

    # RPC credentials
    if args.rpc_creds and args.rpc_login_file:
        utils.die('--rpc-creds and --rpc-login-file are not compatible together. Pick one.')
    if args.rpc_creds:
        rpc_config['rpc_creds'] = args.rpc_creds
    elif args.rpc_login_file:
        with open(args.rpc_login_file, 'r') as fp:
            rpc_config['rpc_creds'] = fp.read().strip()

    # --test-conversions
    #if args.test_conversions:
    #    test_atomic_conversions()
    #    return

    # Register exit handler to handle the daemons
    atexit.register(cleanup)

    # Start daemon?
    # --autostart-daemon/--no-autostart-daemon
    daemon_pid = None
    if args.autostart_daemon and not args.show_parameters:
        daemon_pid = start_daemon(config=args.daemon_config,
                                   data_dir=daemon_data_dir,
                                   additional_args=daemon_args)

    # Start wallet RPC?
    # --autostart-wallet-rpc/--no-autostart-wallet-rpc
    wallet_rpc_pid = None
    if args.autostart_wallet_rpc and not args.show_parameters:
        wallet_rpc_pid = start_wallet_rpc(creds=rpc_config['rpc_creds'],
                         port=default_rpc_port,
                         wallet_file=wallet_file,
                         wallet_password=args.wallet_password,
                         daemon_address=daemon_address,
                         additional_args=args.rpc_arg)

    # Make an arbitrary monero wallet RPC request and exit?
    # --wallet-request
    if args.wallet_request:
        parts = args.wallet_request.split('?')

        method = parts[0]
        if len(parts) > 1:
            encoded = parts[1]
            decoded = urllib.parse.parse_qsl(encoded)
            params = {}
            for pair in decoded:
                key = pair[0]
                value = pair[1]

                # boolean?
                if value.lower() == 'true':
                    value = True
                elif value.lower() == 'false':
                    value = False

                # integer?
                if is_int(value):
                    value = int(value)

                params[key] = value
        else:
            params = None

        utils.info('Making wallet API request: {} params={}'.format(method, params))
        try:
            result = wallet_api(method, params, **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        pprint.pprint(result)
        return

    # Show wallet balances and exit?
    # -B/--balances
    if args.balances:
        display_wallet_balances(**rpc_config)
        return

    # Show wallet addresses and exit?
    # --addresses
    if args.addresses or args.unused:
        display_wallet_addresses(unused_only=args.unused, **rpc_config)
        return
    
    # Churn?
    # --churn
    if args.churn:
        if args.account is not None:
            account, display_label = find_account(args.account, **rpc_config)
        else:
            account = 0
            display_label = 'Primary (0)'

        unlocked_balance = wallet_get_balance(account, unlocked=True, **rpc_config)

        if not unlocked_balance:
            utils.die('Account {} has no unlocked balance. Unable to churn.'.format(account))

        if args.mixins:
            xmr_mixins = args.mixins
        else:
            xmr_mixins = default_autopay_mixins_minimum

        try:
            result = wallet_create_address(account=account, label='Churn', **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        utils.info('Churning {} XMR in account {} to address {}'.format(from_atomic(unlocked_balance), display_label, result['address']))

        try:
            result = wallet_transfer(result['address'], 'all', account=account,
                                     mixins=xmr_mixins, **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        #each_transfer = unlocked_balance / args.churn_transactions
        #even_divide = each_transfer % 1 == 0
        #each_transfer = math.floor(each_transfer)

        #utils.info('Unlocked balance in account {} is {}. Making {} transfers.'.format(display_label,
        #    from_atomic(unlocked_balance), args.churn_transactions))

        # One iteration for each transaction
        #for i in range(args.churn_transactions):
        #    if i == 0 and not even_divide:
        #        transfer_amount = each_transfer + 1
        #    else:
        #        transfer_amount = each_transfer

        #    try:
        #        result = wallet_create_address(account=account, label='Churn', **rpc_config)
        #    except Exception as e:
        #        # RPC request failed
        #        utils.die(str(e))

        #    try:
        #        result = wallet_transfer(result['address'], transfer_amount, account=account,
        #                mixins=xmr_mixins, **rpc_config)
        #    except Exception as e:
        #        # RPC request failed
        #        utils.die(str(e))

        #    utils.good('Sent {} XMR to {}'.format(from_atomic(transfer_amount), result['address']))

        return

    # Create wallet address and exit?
    # -C/--create-address
    if args.create_address:
        if args.account is not None:
            account, display_label = find_account(args.account, **rpc_config)
        else:
            account = 0
            display_label = 'Primary (0)'

        try:
            result = wallet_create_address(account=account, label=args.create_address, **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        utils.good('Created address {} (index {}) in account {}'.format(result['address'],
            result['address_index'],
            display_label))

        return

    # Check the status of an order?
    # -S/--status
    if args.status:
        utils.info('Retrieving order status for {}...'.format(args.status))
        display_order_status(args.status)
        return

    if args.address and len(args.address) == 95:
        bitcoin_payment = False
    else:
        bitcoin_payment = True

    if bitcoin_payment or args.show_parameters or args.estimate:
        # Get order parameters and XMR/BTC price from xmr.to
        utils.info('Retrieving xmr.to parameters...')
        try:
            parameters = xmrto_api_order_parameters()
        except Exception as e:
            # API request failed
            utils.die(str(e))
        utils.subline('- Price: {} BTC/XMR'.format(parameters['price']))
        utils.subline('- Lower limit: {} BTC'.format(parameters['lower_limit']))
        utils.subline('- Upper limit: {} BTC'.format(parameters['upper_limit']))
        if parameters['zero_conf_enabled']:
            utils.subline('- Zero conf max: {} BTC'.format(parameters['zero_conf_max_amount']))

        # Only show the xmrto parameters?
        # -P/--show-parameters
        if args.show_parameters:
            return

        # Check and convert amount
        if args.amount == 'max':
            amount = decimal.Decimal(parameters['upper_limit'])
        elif args.amount == 'min':
            amount = decimal.Decimal(parameters['lower_limit'])
        elif args.amount == 'zeroconf':
            if not parameters['zero_conf_enabled']:
                utils.die('Zero-conf not enabled')
            amount = parameters['zero_conf_max_amount']
        elif args.amount is None or args.address is None:
            utils.die('Provide a destination address')
        elif not args.amount and ':' not in args.address:
            utils.die('{} is not a payment URL. Specify a transaction amount.'.format(args.address))
        else:
            try:
                amount = decimal.Decimal(args.amount)
            except decimal.InvalidOperation:
                utils.die('Invalid amount: {}'.format(args.amount))

        # Show fiat amount?
        # -f/--fiat
        if args.fiat and args.fiat != 'off':
            utils.info('Getting fiat value in {}...'.format(args.fiat))
            fiat_note = btcven_convert_note(amount, fiat=args.fiat)
        else:
            fiat_note = ''

        # Only show the estimate?
        # -E/--estimate
        if args.estimate:
            xmr_estimate = amount / decimal.Decimal(parameters['price'])
            utils.good('Estimate: {:.4f} XMR -> {} BTC{}'.format(xmr_estimate, amount, fiat_note))
            return

        # Check address
        if not args.address:
            utils.die('Specify an address or payment URL to send to')

    if not bitcoin_payment:
        # Monero payment
        if args.mixins:
            xmr_mixins = args.mixins
        else:
            xmr_mixins = default_autopay_mixins_minimum

        # Pick an account
        if args.amount == 'all':
            from_account_index = 0
            display_label = 'Primary (0)'
        else:
            try:
                from_account_index, display_label = find_account(args.account, to_atomic(args.amount), **rpc_config)
            except Exception as e:
                # Failed to find account
                utils.die(str(e))

        try:
            result = wallet_transfer(args.address, to_atomic(args.amount), account=from_account_index,
                                     mixins=xmr_mixins, **rpc_config)
        except Exception as e:
            # RPC request failed
            utils.die(str(e))

        utils.good('Sent {} XMR to {}'.format(args.amount, args.address))

    else:
        # Bitcoin xmr.to payment
        if amount:
            # Make sure amount is in-bounds
            if amount > decimal.Decimal(parameters['upper_limit']):
                utils.die('{} is above the upper limit of {}'.format(amount, parameters['upper_limit']))

            if amount < decimal.Decimal(parameters['lower_limit']):
                utils.die('{} is below the lower limit of {}'.format(amount, parameters['lower_limit']))

            # Let the user know what the order will look like
            if amount <= decimal.Decimal(parameters['zero_conf_max_amount']):
                zero_conf_note = ' (zero-conf)'
            else:
                zero_conf_note = ''

            utils.info('Creating order to {} for {} BTC{}{}...'.format(args.address, amount, fiat_note, zero_conf_note))
        else:
            # Payment URL order
            utils.info('Creating order to {}...'.format(args.address))

        # Submit order
        try:
            uuid = xmrto_api_order_create(args.address, amount)['uuid']
        except Exception as e:
            # API request failed
            utils.die(str(e))

        # Wait until the order is ready to pay (usually immediate)
        utils.good('Order created: {}'.format(uuid))
        utils.info('Waiting for order to be payable...')
        while True:
            try:
                status = xmrto_api_order_status(uuid)
                state = status['state'] 
            except Exception as e:
                # API request failed
                utils.die(str(e))

            if state not in ('TO_BE_CREATED', 'UNPAID'):
                # Unexpected state
                utils.die('Received unexpected order state: {}'.format(states[state]))

            if state == 'UNPAID':
                # Ready to pay
                xmr_amount = decimal.Decimal(status['incoming_amount_total'])
                xmr_amount_atomic = to_atomic(xmr_amount)
                xmr_address = status['receiving_subaddress']
                recommended_xmr_mixins = max(status['recommended_mixin'], default_autopay_mixins_minimum)
                expires_in = status['seconds_till_timeout']
                break

            time.sleep(1)

        # Autopay?
        # -a/--autopay
        if args.autopay:
            if args.mixins:
                xmr_mixins = args.mixins
            else:
                xmr_mixins = recommended_xmr_mixins

            # Safety check the max autopay amount
            if xmr_amount > args.max_autopay:
                utils.die('{} XMR is above the maximum autopay amount of {} XMR. See -m/--max-autopay'.format(xmr_amount, args.max_autopay))

            try:
                account_info = wallet_get_accounts(**rpc_config)
            except Exception as e:
                # RPC 'get_accounts' request failed
                utils.die(str(e))

            accounts = account_info['subaddress_accounts']
            total_balance_atomic = account_info['total_balance']
            total_unlocked_balance_atomic = account_info['total_unlocked_balance']

            # Pick an account
            try:
                from_account_index, display_label = find_account(args.account, xmr_amount_atomic, **rpc_config)
            except Exception as e:
                # Failed to find account
                utils.die(str(e))

            utils.good('Paying {} XMR to {} from account {}'.format(xmr_amount, xmr_address, display_label))

            # Safety checks
            utils.debug('XMR amount: {}'.format(xmr_amount))
            utils.debug('XMR atomic amount: {}'.format(xmr_amount_atomic))
            if xmr_amount != from_atomic(xmr_amount_atomic):
                raise RuntimeError('Atomic conversion safety check failed. {} != {}'.format(xmr_amount, from_atomic(xmr_amount_atomic)))

            # Make the transfer
            try:
                wallet_transfer(xmr_address,
                                xmr_amount_atomic,
                                account=from_account_index,
                                priority=args.priority,
                                mixins=xmr_mixins,
                                unlock_time=args.unlock_time,
                                **rpc_config)
            except Exception as e:
                # RPC 'transfer' request failed
                utils.die(str(e))
        else:
            utils.good('Pay {} XMR to {} within {} seconds. {} mixins recommended.'.format(xmr_amount, xmr_address, expires_in, recommended_xmr_mixins))

        # Show status until finished?
        # -n/--no-status
        if not args.no_status:
            print()
            utils.info('Polling order status until complete...')

            # Show status until paid
            while True:
                try:
                    status = xmrto_api_order_status(uuid)
                except Exception as e:
                    # API request failed
                    utils.die(str(e))
                state = status['state'] 

                if state == 'BTC_SENT':
                    utils.good('{} BTC sent to {}'.format(status['btc_amount'], status['btc_dest_address']))
                    utils.subline('UUID: {}'.format(status['uuid']))
                    for payment in status['payments']:
                        utils.subline('Transaction: {} (amount: {}) (confirms: {})'.format(payment['tx_id'],
                            payment['amount'], payment['num_confirmations']))
                    break
                elif state == 'TIMED_OUT':
                    utils.bad('Order timed out')
                    break
                elif state == 'NOT_FOUND':
                    utils.bad('Order missing')
                    break
                else:
                    # Waiting for payment
                    out = 'Status: {}'.format(states[state])
                    if state in ('UNPAID', 'UNDERPAID', 'PAID_UNCONFIRMED'):
                        out += '. Expires in: {} seconds'.format(status['seconds_till_timeout'])
                    utils.info(out)

                    if state == 'UNDERPAID':
                        # Underpaid
                        utils.info('{} XMR remaining'.format(status['remaining_amount_incoming']))
                    elif state == 'PAID_UNCONFIRMED':
                        # Paid, unconfirmed
                        utils.info('Paid. {} confirmations remaining'.format(status['incoming_num_confirmations_remaining']))

                time.sleep(default_status_sleep)

if __name__ == '__main__':
    main()
